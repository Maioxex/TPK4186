# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1FBvjcuOw3EpHqjn8bbObVgtUMfiOmpKC
"""

# TPK4186 - Assignment 1: Discrete-Time Markov Chains - 2022
# Simen MÃ¸ller, Jonas Lund and Markus Vonheim

# 2.1 Data Structure to encode DTMC and probablity distributions

# Task 1. Data structure to encode DTMC 
# 1.1) States
# ----------------------------------------------------------------------------

def States_New(name):
  return [name]

def States_GetName(state):
  return state[0]

# 1.2) Transitions
# ----------------------------------------------------------------------------

def Transition_New(name, sourceState, targetState, transitionProbability):
  return [name, sourceState, targetState, transitionProbability]

def Transition_GetName(transition):
  return transition[0]

def Transition_GetSourceState(transition):
  return transition[1]

def Transition_GetTargetState(transition):
  return transition[2]

def Transition_GetProbability(transition):
  return transition[3]

def Transition_CheckProbabilityValue(transitionProbability):
  value = True
  if transitionProbability<0 or transitionProbability >1:
    value =False
  return value 
  

# 1.3) Graph description of Markov chain (DTMC)
# ----------------------------------------------------------------------------

def DTMC_New(name):
  states = dict()
  transitions = dict()
  return [name, states, transitions]

def DTMC_GetName(graph):
  return graph[0]

def DTMC_GetStates(graph):
  return graph[1]

def DTMC_LookForState(graph, name):
  states = DTMC_GetStates(graph)
  return states.get(name, None)

def DTMC_NewState(graph, stateName):
  state = DTMC_LookForState(graph, stateName)
  if state!=None:
    return None
  state = States_New(stateName)
  states = DTMC_GetStates(graph)
  states[stateName] = state
  return state

def DTMC_GetTransitions(graph):
  return graph[2]

def DTMC_LookForTransition(graph, name):
  transitions = DTMC_GetTransitions(graph)
  return transitions.get(name, None)

def DTMC_CheckExistingTransition(graph, sourceState, targetState):
    transitions = DTMC_GetTransitions(graph)
    for transitionName in transitions:
        transition = transitions[transitionName]
        if Transition_GetSourceState(transition) == sourceState and Transition_GetTargetState(transition) == targetState:
            return True
    else:
        return False

def DTMC_NewTransition(graph, transitionName, sourceState, targetState, transitionProbability):
  transition = DTMC_LookForTransition(graph, transitionName)
  if transition!=None:
    return None
  elif sourceState == targetState:
      print("Transition: " + States_GetName(sourceState) + " to " + States_GetName(targetState) +" is not possible.")
      print("\tIt is not possible with loops, i.e., no transition from a state to itself.\n")
      return None
  elif DTMC_CheckExistingTransition(graph, sourceState, targetState):
      print("Transition: " + States_GetName(sourceState) + " to " + States_GetName(targetState) +" already exists.")
      print("\tFor any pair of states 's' and 't', there is at most one transition from 's' to 't'\n")
      return None
  elif Transition_CheckProbabilityValue(transitionProbability)==False:
    print("Transition: " + States_GetName(sourceState) + " to " + States_GetName(targetState) +" is not possible.")
    print("\tThe probability is " + str(transitionProbability))
    print("\tMake sure the value of the probability is between 0 and 1")
    return None
  transition = Transition_New(transitionName, sourceState, targetState, transitionProbability)
  transitions = DTMC_GetTransitions(graph)
  transitions[transitionName] = transition
  return transition


# 1.4. Printer
# ----------------------------------------------------------------------------

def Printer_PrintMarkovGraph(graph):
  name = DTMC_GetName(graph)
  print("Graph: " + name)
  for stateNames in DTMC_GetStates(graph):
    print("  State: " + stateNames)
  transitions = DTMC_GetTransitions(graph)
  for transitionName in transitions:
    transition = transitions[transitionName]
    Printer_PrintTransition(transition)

def Printer_PrintTransition(transition):
  name = Transition_GetName(transition)
  sourceState = Transition_GetSourceState(transition)
  sourceStateName = States_GetName(sourceState)
  targetState = Transition_GetTargetState(transition)
  targetStateName = States_GetName(targetState)
  print("  Transition %s %-10s -> \t %s" %(name,sourceStateName,targetStateName))
  
    
# 1.5. Explorer
# ----------------------------------------------------------------------------

def Explorer_ExtractAdjacentTransitions(graph, sourceState):
  transitions = DTMC_GetTransitions(graph)
  adjacentTransitions = []
  for transitionName in transitions:
    transition = transitions[transitionName]
    if Transition_GetSourceState(transition)==sourceState:
      adjacentTransitions.append(transition)
  return adjacentTransitions

def Explorer_ExtractAdjacentStates(graph, sourceState):
  transitions = Explorer_ExtractAdjacentTransitions(graph, sourceState)
  targetStates = []
  for transition in transitions:
     targetStates.append(Transition_GetTargetState(transition))
  return targetStates

# def Explorer_ExtractReachableNodes(graph, sourceNode):
#   reachableNodes = []
#   candidateNodes = [sourceNode]
#   while len(candidateNodes)>0:
#     node = candidateNodes.pop(0)
#     reachableNodes.append(node)
#     adjacentNodes = Explorer_ExtractAdjacentStates(graph, node)
#     for adjacentNode in adjacentNodes:
#       if adjacentNode not in reachableNodes and adjacentNode not in candidateNodes:
#         candidateNodes.append(adjacentNode)
#   return reachableNodes

def Explorer_FindPath(graph, sourceNode, targetNode, visitedNodes):
  if sourceNode==targetNode:
    return []
  adjacentEdges = Explorer_ExtractAdjacentTransitions(graph, sourceNode)
  for adjacentEdge in adjacentEdges:
    adjacentNode = Transition_GetTargetState(adjacentEdge)
    if adjacentNode not in visitedNodes:
      visitedNodes.append(adjacentNode)
      path = Explorer_FindPath(graph, adjacentNode, targetNode, visitedNodes)
      if path!=None:
        name = Transition_GetName(adjacentEdge)
        path.insert(0, name)
        return path
  return None
    

# ****************************************************************************
# Task 2. Data structure to encode probability distribution
# 1. Name
# 2. Reference to DTMC 
# 3. For each state of DTMC, a probability



# 2.1) Probability distribution
# ----------------------------------------------------------------------------

#def probability_New(probability):
#    return probability

# ----------------------------------------------------------------------------

def ProbDist_New(name, graph):
    probabilities = dict()
    return [name, graph, probabilities]

def ProbDist_GetName(probDist):
    return probDist[0]

def ProbDist_GetDTMC(probDist):
    return probDist[1]

def ProbDist_GetProbabilityDistribution(probDist):
    return probDist[2]

#def ProbDist_GetStates(probDist):
#    return DTMC_GetStates(ProbDist_GetGraph(probDist))

def ProbDist_GetStateProbability(probDist, state):
    probabilities = ProbDist_GetProbabilityDistribution(probDist)
    return probabilities[state[0]]

def ProbDist_NewProbability(probDist, probability, state):
    #prob = probability_New(probability)
    probabilities = ProbDist_GetProbabilityDistribution(probDist)
    probabilities[state[0]] = probability
    return probabilities[state[0]]

#Jonas sin blokk
#Task 3. Manage sets of DTMC and probability distributions

#Simen sin blokk
#Task 5. Printing DTCM and probability distributions into file 
def Printer_ToFile_DTCM(DTMC,filename):
  f = open(filename,"w") 
  f.write("Markov Chain " + DTMC_GetName(DTMC)+"\n")
  transitions= DTMC_GetTransitions(DTMC)
  for transition in transitions:
    f.write(Transition_GetName(Transition_GetSourceState(transition))+" --> "+Transition_GetName(Transition_GetTargetState(transition))+": "+str(Transition_GetProbability(transition))+";\n")
  f.write("end\n")
  f.close()

#Markus sin blokk 
#Task 6. Design a data structure to encode tokens and implement the associated management functions.

"""# Test Section"""

# 1.6. Test
# ----------------------------------------------------------------------------
#Task 1
Douglas_Sea_Scale = DTMC_New("Douglas sea scale")

CALM = DTMC_NewState(Douglas_Sea_Scale, "CALM")
MODERATE = DTMC_NewState(Douglas_Sea_Scale, "MODERATE")
ROUGH = DTMC_NewState(Douglas_Sea_Scale, "ROUGH")
CALM_MODERATE = DTMC_NewTransition(Douglas_Sea_Scale, "1", CALM, MODERATE,0.4)
CALM_MODERATE = DTMC_NewTransition(Douglas_Sea_Scale, "6", CALM, MODERATE,0.4)
CALM_MODERATE = DTMC_NewTransition(Douglas_Sea_Scale, "6", CALM, CALM,0.6)
MODERATE_CALM = DTMC_NewTransition(Douglas_Sea_Scale, "2", MODERATE, CALM,0.6)
MODERATE_ROUGH = DTMC_NewTransition(Douglas_Sea_Scale, "3", MODERATE, ROUGH,0.1)
ROUGH_CALM = DTMC_NewTransition(Douglas_Sea_Scale, "4", ROUGH, CALM,0.0)

Printer_PrintMarkovGraph(Douglas_Sea_Scale)

#------------------------------------------------------------------------------
#Task 2
TestProbability = ProbDist_New("TestName", Douglas_Sea_Scale)
print(TestProbability)

pCALM_Test = ProbDist_NewProbability(TestProbability, 1.0, CALM)
pMODERATE_Test = ProbDist_NewProbability(TestProbability, 0.0, MODERATE)
pROUGH_Test = ProbDist_NewProbability(TestProbability, 0.0, ROUGH)

testProbReturn = ProbDist_GetStateProbability(TestProbability, CALM)
print(testProbReturn)
testProbReturn *=0.5

print(TestProbability)
#ProbDist_GetProbabilityDistribution(TestProbability)['pCalm'][1] *= 0.75
#print(ProbDist_GetProbabilityDistribution(TestProbability)['pCalm'][1])


#------------------------------------------------------------------------------
#Task 5
#Printer_ToFile_DTCM(Douglas_Sea_Scale,"test.txt")




#------------------------------------------------------------------------------
#Task 6